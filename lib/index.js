var juice = require('juice');
var fs = require('fs');
var nunjucks = require('nunjucks');
var cheerio = require('cheerio');
var path = require('path');
var less = require('less');
//var sanitizeHtml = require('sanitize-html');
var htmlBeautify = require('html-beautify');


// TODO: Separate nunjucks settings from postboy settings
var default_options = {
  options: {
    entry: 'index.njk',
    source: './',
    result: './result/',
    result_filename: 'index.html',

    css_embed: 'css/embed.css',
    less_embed: 'css/embed.less',
    css_inline: 'css/inline.css',
    less_inline: 'css/inline.less',

    wrap_anchors: true,
    autoescape: false,
    strip_comments: true,
    beautify: false,
    remove_classes: true,
    replace_shorthand_colors: true
  },
  variables: {}
};

var App = function (options, variables, less_variables, cwd) {
  this.cwd = cwd || path.resolve('.');
  this.less_variables = less_variables || {};
  this.env_vars = [];
  this.options = Object.assign(default_options.options, options);
  this.variables = Object.assign(default_options.variables, variables);
};

App.prototype = {

  compile: function () {

    //TODO: Clean the spagetti
    //TODO: Fix the escaping (decodeEntities?)

    var file = path.resolve(this.options.source, this.options.entry);
    if (!fs.existsSync(file)) {
      console.log(file+' not found.');
      return 1;
    }
    nunjucks.configure(this.options);

    var variables = this.variables;

    this.env_vars.forEach(function (envvar) {
      variables[envvar] = variables[envvar] || true;
    });

    console.log('Rendering nunjucks file '+file);
    var result = nunjucks.render(file, variables);

    //result = this.mergeStyles(result);

    if (this.options.wrap_anchors) {result = this.wrapAnchors(result);}

    var css_inline_path = path.resolve(this.options.source, this.options.css_inline);
    var less_inline_path = path.resolve(this.options.source, this.options.less_inline);
    var css_embed_path = path.resolve(this.options.source, this.options.css_embed);
    var less_embed_path = path.resolve(this.options.source, this.options.less_embed);

    this.compileLESS(less_inline_path, css_inline_path, function () {
      this.compileLESS(less_embed_path, css_embed_path, function () {

        result = this.inlineFile(result, css_inline_path);
        result = this.embedStyleFile(result, css_embed_path);

        if (this.options.remove_classes) {result = this.removeClasses(result);}
        if (this.options.strip_comments) {result = result.replace(/<!--[\s\S]*?-->/gm, '');}
        if (this.options.replace_shorthand_colors) {result = this.replaceShorthandColors(result);}
        // if (this.options.sanitize){result = sanitizeHtml(result, {
        //     allowedTags: false,
        //     allowedAttributes: false,
        //     allowedSchemes: false
        //   });
        //}
        if (this.options.beautify) { result = htmlBeautify(result)};

        var result_path = path.resolve(this.options.result, this.options.result_filename);
        console.log('Writing '+result_path);
        fs.writeFileSync(result_path, result, 'utf-8');
      });
    });
  },

  compileLESS: function (from, to, callback) {
    if (fs.existsSync(from)) {
      var input = fs.readFileSync(from, 'utf-8');

      var less_options = {
        globalVars: this.less_variables
      };
      var that = this;

      less.render(input, less_options)
        .then(function (output) {
            output.css = "/*This file was generated by LESS. If source LESS file is present this CSS file may be overwritten while compiling the source.*/\r\n" + output.css;
            fs.writeFileSync(to, output.css, 'utf-8');
            callback.call(that);
          },
          function (error) {
            console.log('Error while compiling ' + from + ':', error);
          });
    }
    else {
      callback.call(this);
    }
  },

  envVars: function(vars){
    this.env_vars = vars;
  },

  inlineFile: function (html, file) {
    if (fs.existsSync(file)) {
      var inline = fs.readFileSync(file, 'utf-8');
      html = juice.inlineContent(html, inline);
    }
    return html;
  },

  replaceShorthandColors: function (html) {
    // Any better way to do this? ;-)
    var regex = /#([a-f0-9])([a-f0-9])([a-f0-9])([^a-f0-9])/ig;
    return html.replace(regex, '#$1$1$2$2$3$3$4');
  },

  wrapAnchors: function (html) {
    var $ = cheerio.load(html,{decodeEntities:false});
    $('a[href]:not(a[nowrap])').each(function () {
      $(this).html('<span class="anchor_wrap">' + $(this).html() + '</span>');
    });
    return $.html();
  },

  mergeStyles: function (html) {
    html = html.replace(/<[a-zA-Z]+(>|.*?[^?]>)/g, function (tag) {
      ['class'].forEach(function (attr) {
        var regex = (new RegExp(attr+'\\s*=\\s*"(.*?)"','ig'));
        var m;
        while ((m = regex.exec(tag)) !== null) {
          if (m.index === regex.lastIndex) { regex.lastIndex++; }
          m.forEach(function(match, groupIndex) {
            if(groupIndex)console.log(match);
          });
        }
      });
      return tag;
    });
    return html;
  },

  removeClasses: function (html) {
    var $ = cheerio.load(html,{decodeEntities:false});
    $('[class]').each(function () {
      $(this).removeAttr('class');
    });
    return $.html();
  },

  embedStyleFile: function (html, file) {
    if (fs.existsSync(file)) {
      var embed = fs.readFileSync(file, 'utf-8');
      var style_tag = '<style type="text/css">' + embed + '</style>';

      var $ = cheerio.load(html);
      var head = $('head');
      if (head[0]) {
        head.append(style_tag);
        html = $.html();
      }
      else html += style_tag;
    }
    return html;
  }

};

module.exports = App;